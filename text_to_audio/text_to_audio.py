# -*- coding: utf-8 -*-
"""Copy of kalasetu-speech

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ShGa3clxzLNIZLcKtFpi_zueAPUJxcKH
"""



import torch
from transformers import AutoProcessor, BarkModel
from scipy.io.wavfile import write
import numpy as np
from IPython.display import Audio, FileLink, HTML, display
import os
import json
import requests
from flask import Flask, request, jsonify
from pyngrok import ngrok
import threading
import time
import boto3
from botocore.config import Config
from datetime import datetime

# Step 1: Set up device and data type
device = "cuda:0" if torch.cuda.is_available() else "cpu"
torch_dtype = torch.float16 if "cuda" in device else torch.float32
print(f"Using device: {device}")

# Step 2: Load model and explicitly move it to the device
model = BarkModel.from_pretrained("suno/bark", torch_dtype=torch_dtype).to(device)
processor = AutoProcessor.from_pretrained("suno/bark")
print("Bark model loaded successfully!")

from groq import Groq

# Initialize Groq client (you'll need to set your API key)
GROQ_API_KEY = ""  # Replace with your actual API key
groq_client = Groq(api_key=GROQ_API_KEY)

def detect_emotions_groq(text):
    """Detect emotions in text using Groq LLM"""
    try:
        prompt = f"""
        Analyze the emotions in the following text and return a JSON response with emotion scores (0-1):

        Text: "{text}"

        Return only a JSON object with these emotions and their confidence scores:
        {{
            "joy": 0.0,
            "sadness": 0.0,
            "anger": 0.0,
            "fear": 0.0,
            "surprise": 0.0,
            "disgust": 0.0,
            "neutral": 0.0,
            "dominant_emotion": "emotion_name"
        }}
        """

        response = groq_client.chat.completions.create(
            messages=[{"role": "user", "content": prompt}],
            model="llama3-8b-8192",
            temperature=0.3,
            max_tokens=200
        )

        result = response.choices[0].message.content.strip()
        # Extract JSON from response
        start_idx = result.find('{')
        end_idx = result.rfind('}') + 1
        json_str = result[start_idx:end_idx]

        return json.loads(json_str)
    except Exception as e:
        print(f"Error detecting emotions: {e}")
        return {
            "joy": 0.0, "sadness": 0.0, "anger": 0.0, "fear": 0.0,
            "surprise": 0.0, "disgust": 0.0, "neutral": 1.0,
            "dominant_emotion": "neutral"
        }

# Supabase S3 Configuration
SUPABASE_ACCESS_KEY = "0065f886443287967b45f2ac060befbb"
SUPABASE_SECRET_KEY = "f687b0cc7273c4b2463ca0b02386e93d55272ddd3fb05925253c0521ddcc32db"
SUPABASE_ENDPOINT = "https://gbdgtveuufrfqbywgxvy.supabase.co/storage/v1/s3"
SUPABASE_REGION = "ap-south-1"
BUCKET_NAME = "audios"  # Replace with your actual bucket name

# Initialize S3 client for Supabase
s3_client = boto3.client(
    's3',
    endpoint_url=SUPABASE_ENDPOINT,
    aws_access_key_id=SUPABASE_ACCESS_KEY,
    aws_secret_access_key=SUPABASE_SECRET_KEY,
    region_name=SUPABASE_REGION,
    config=Config(signature_version='s3v4')
)

def generate_speech_bark(text, emotion="neutral", output_filename="output.wav"):
    """Generate speech using Bark model with emotion consideration"""
    try:
        # Map emotions to voice presets and add emotional context
        emotion_voice_mapping = {
            "joy": "v2/en_speaker_6",
            "sadness": "v2/en_speaker_7",
            "anger": "v2/en_speaker_8",
            "fear": "v2/en_speaker_9",
            "surprise": "v2/en_speaker_6",
            "neutral": "v2/en_speaker_6"
        }

        # Add emotional context to text
        emotion_prefixes = {
            "joy": "[laugh] ",
            "sadness": "[sigh] ",
            "anger": "[frustrated] ",
            "fear": "[whisper] ",
            "surprise": "[gasp] ",
            "neutral": ""
        }

        voice_preset = emotion_voice_mapping.get(emotion, "v2/en_speaker_6")
        emotional_text = emotion_prefixes.get(emotion, "") + text

        # Process and generate
        inputs = processor(emotional_text, voice_preset=voice_preset, return_tensors="pt")
        inputs = {key: value.to(device) for key, value in inputs.items()}

        pad_token_id = processor.tokenizer.pad_token_id
        with torch.no_grad():
            audio_array = model.generate(**inputs, pad_token_id=pad_token_id).squeeze().cpu().numpy()

        # Save audio
        sample_rate = model.generation_config.sample_rate
        audio_array = audio_array.astype(np.float32)
        write(output_filename, rate=sample_rate, data=audio_array)

        return output_filename
    except Exception as e:
        print(f"Error generating speech: {e}")
        return None

def upload_to_supabase(file_path, filename):
    """Upload audio file to Supabase storage and return public URL"""
    try:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        unique_filename = f"audio_{timestamp}_{filename}"

        # Upload using S3 endpoint
        s3_client.upload_file(
            file_path,
            BUCKET_NAME,
            unique_filename,
            ExtraArgs={'ContentType': 'audio/wav'}
        )

        # Generate public URL using REST API endpoint (NOT S3 endpoint)
        public_url = f"https://gbdgtveuufrfqbywgxvy.supabase.co/storage/v1/object/public/{BUCKET_NAME}/{unique_filename}"

        if os.path.exists(file_path):
            os.remove(file_path)

        return public_url

    except Exception as e:
        print(f"Error uploading to Supabase: {e}")
        return None

from flask_cors import CORS  # Add this import

app = Flask(__name__)
CORS(app)

# app = Flask(__name__)

@app.route('/')
def index():
    return HTML_INTERFACE

@app.route('/detect_emotion', methods=['POST'])
def detect_emotion_endpoint():
    data = request.json
    text = data.get('text', '')

    if not text:
        return jsonify({'error': 'No text provided'}), 400

    emotions = detect_emotions_groq(text)
    return jsonify(emotions)

@app.route('/generate_speech', methods=['POST'])
def generate_speech_endpoint():
    data = request.json
    text = data.get('text', '')
    emotion = data.get('emotion', 'neutral')

    if not text:
        return jsonify({'error': 'No text provided'}), 400

    filename = f"speech_{int(time.time())}.wav"
    print(f"Generating speech for: {text}")

    local_file = generate_speech_bark(text, emotion, filename)
    print(f"Local file generated: {local_file}")

    if local_file:
        print("Attempting to upload to Supabase...")
        public_url = upload_to_supabase(local_file, filename)
        print(f"Upload result: {public_url}")

        if public_url:
            return jsonify({
                'success': True,
                'filename': filename,
                'audio_url': public_url,
                'message': 'Speech generated and uploaded successfully'
            })
        else:
            return jsonify({'error': 'Failed to upload audio to storage'}), 500
    else:
        return jsonify({'error': 'Failed to generate speech'}), 500

def run_flask():
    app.run(host='0.0.0.0', port=5000, debug=False)

# Start Flask server in a separate thread
import threading
import time


def start_server():
    threading.Thread(target=run_flask, daemon=True).start()
    time.sleep(3)  # Wait for server to start

    # Create ngrok tunnel
    ngrok.set_auth_token(os.getenv("NGROK_AUTH_TOKEN", "30XiacceR6V2FrnLqzyWgJRp51x_2r5S7wUevhrWUqK7dYFLW"))
    public_url = ngrok.connect(5000)
    print(f"Flask server is running!")
    print(f"Public URL: {public_url}")
    print(f"Access your interface at: {public_url}")

    return public_url

# Don't forget to set your Groq API key first!
GROQ_API_KEY = "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"

public_url = start_server()